import{_ as e,o as a,c as t,Q as i}from"./chunks/framework.f16e6129.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Diary/2022/2022.8.1.md","filePath":"pages/Diary/2022/2022.8.1.md"}'),o={name:"pages/Diary/2022/2022.8.1.md"},r=i(`<h2 id="postcss-改造css代码" tabindex="-1">postCSS 改造CSS代码 <a class="header-anchor" href="#postcss-改造css代码" aria-label="Permalink to &quot;postCSS 改造CSS代码&quot;">​</a></h2><h2 id="自定义参数校验" tabindex="-1">自定义参数校验 <a class="header-anchor" href="#自定义参数校验" aria-label="Permalink to &quot;自定义参数校验&quot;">​</a></h2><h2 id="全局的新建编辑" tabindex="-1">全局的新建编辑 <a class="header-anchor" href="#全局的新建编辑" aria-label="Permalink to &quot;全局的新建编辑&quot;">​</a></h2><p>使用全局指令控制按钮的显示和隐藏 根据鉴权接口返回的结果在父组件中移除DOM实例 通过vue指令限制向无权限用户展示新建上线和编译等按钮</p><h2 id="webpack-vs-vite-——-vite是如何缩短本地hmr时间的" tabindex="-1">webpack vs Vite —— Vite是如何缩短本地HMR时间的 <a class="header-anchor" href="#webpack-vs-vite-——-vite是如何缩短本地hmr时间的" aria-label="Permalink to &quot;webpack vs Vite —— Vite是如何缩短本地HMR时间的&quot;">​</a></h2><p>npm 包这类基本不会变化的模块，使用 Esbuild 在 预构建 阶段先打包整理好，减少 http 请求数因为引用的包可能也引用了其他很多包 这样请求时间就会很长 js是解释型语言（动态语言）。每次运行编译的时候 V8 引擎都是第一次遇见代码，无法进行任何优化措施。</p><ol><li><p>使用 Go 这种编译型语言（静态语言）编写而成 已经编译成了机器可以直接执行的机器码。当 esbuild 在编译你的 javaScript 代码的时候，可能 Node 还在忙着解析你的构建工具的代码。 Go 在线程之间共享使用内存空间，而 JS 想要在线程间传递数据还需要把数据序列化之后再传送。 Go 和 JS 的并发都有相应的垃圾回收机制，Go 会在所有线程之间共享堆，对于 JS 而言，每一个线程都有一个独立的堆。 根据 esbuild 的作者的测试，这似乎将 JavaScript 的工作线程的并行处理能力减少了一半，可能是因为你的一半 CPU 核心忙于为另一半收集垃圾。 二、大量使用并行算法 除了 Go 语言天生对于并发的优势，使得其处理并发任务性能远远优于 JavaScript， Esbuild 的内部算法也是经过精心设计的，尽可能的压榨所有的 CPU 核心。 三、更有效的利用内存 1.esbuild 通过减少 AST 遍历次数（三次），来减小内存访问速度对于打包速度的影响 2.Go 语言还有一个好处就是可以把数据更加紧凑的储存在内存中，从而使得高速 CPU 缓存可以存下更多的内容</p></li><li><p>启动方式的差异 —— Bundleless</p><p>基于浏览器开始原生的支持 JavaScript 模块功能，JavaScript 模块依赖于 import 和 export 的特性，目前主流浏览器基本都支持 打包是开发者利用打包工具将应用各个模块集合在一起形成 bundle，以一定规则读取模块的代码，以便在不支持模块化的浏览器里使用，并且可以减少 http 请求的数量。但其实在本地开发过程中打包反而增加了我们排查问题的难度，增加了响应时长，Vite 在本地开发命令中去除了打包步骤，从而缩短构建时长。 为了减少 bundle 大小，一般会想要按需加载，主要有两种方式：</p><ul><li>使用动态引入 import() 的方式异步的加载模块，被引入模块依然需要提前编译打包</li><li>使用 tree shaking 等方式尽力的去掉未引用的模块 Vite 的方式更为直接，它只在某个模块被 import 的时候动态的加载它，实现了真正的按需加载，减少了加载文件的体积，缩短了时长</li></ul></li></ol><pre><code>3.  Webpack 会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。
    而 Vite 是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。
    由于现代浏览器本身就支持 ES Module，会自动向依赖的 Module 发出请求。
    Vite 充分利用了这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像 W ebpack 那样进行打包合并。
    由于 Vite 在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译。
    因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。
    这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite 的优势越明显。
    在 HMR（热更新）方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。
    从实际的开发体验来看， 在 Vite 模式下， 开发环境可以瞬间启动， 但是等到页面出来， 要等一段时间。
</code></pre><h3 id="图标描述" tabindex="-1">图标描述 <a class="header-anchor" href="#图标描述" aria-label="Permalink to &quot;图标描述&quot;">​</a></h3><p>实现了对应图表的配置化处理，前端可根据后端传递指标的数据适配展示对应图表数据，封装成对应的直观展示组件antd的Table组件与图表组件相结合，配置更直观的图表数据</p>`,10),s=[r];function l(p,n,c,d,h,_){return a(),t("div",null,s)}const S=e(o,[["render",l]]);export{b as __pageData,S as default};
