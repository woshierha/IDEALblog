import{_ as a,o as e,c as l,Q as i}from"./chunks/framework.f16e6129.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Earnings/代码随想录/栈与队列.md","filePath":"pages/Earnings/代码随想录/栈与队列.md"}'),t={name:"pages/Earnings/代码随想录/栈与队列.md"},r=i('<h2 id="栈和队列问题" tabindex="-1">栈和队列问题 <a class="header-anchor" href="#栈和队列问题" aria-label="Permalink to &quot;栈和队列问题&quot;">​</a></h2><blockquote><p>栈和队列特点</p></blockquote><ul><li>队列先进先出 栈先进后出</li><li>push pop接口 不提供走访功能 不提供迭代器 不能够像set 或者 map来遍历所有元素</li></ul><h2 id="括号匹配" tabindex="-1">括号匹配 <a class="header-anchor" href="#括号匹配" aria-label="Permalink to &quot;括号匹配&quot;">​</a></h2><ul><li>遇到左括号入栈</li><li>遇到右括号，取出栈顶元素，不匹配返回，匹配弹出栈顶元素</li><li>判断最后栈是否为空</li></ul><h2 id="字符串去重" tabindex="-1">字符串去重 <a class="header-anchor" href="#字符串去重" aria-label="Permalink to &quot;字符串去重&quot;">​</a></h2><ul><li>字符串顺序放到一个栈中，如果相同的话栈弹出，这样最后栈里剩下的元素都是相邻不相同的元素。</li></ul><h2 id="逆波兰表达式" tabindex="-1">逆波兰表达式 <a class="header-anchor" href="#逆波兰表达式" aria-label="Permalink to &quot;逆波兰表达式&quot;">​</a></h2><ul><li>遇到符号就取出来前两个数字运算，运算之后再把它塞回去继续运算</li></ul><h2 id="滑动窗口的最大值" tabindex="-1">滑动窗口的最大值 <a class="header-anchor" href="#滑动窗口的最大值" aria-label="Permalink to &quot;滑动窗口的最大值&quot;">​</a></h2><ul><li></li></ul><h2 id="求前k个高频元素" tabindex="-1">求前k个高频元素 <a class="header-anchor" href="#求前k个高频元素" aria-label="Permalink to &quot;求前k个高频元素&quot;">​</a></h2><ul><li>用一个map存下他的key 和 val</li><li>转换成二维数组排序,倒序</li><li>取出前k个的 [0,1] 0部分</li></ul>',13),o=[r];function n(s,h,c,u,d,_){return e(),l("div",null,o)}const k=a(t,[["render",n]]);export{m as __pageData,k as default};
