import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.36c93c4c.js";const p="/assets/环形链表入口.c865600d.png",x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Earnings/代码随想录/链表.md","filePath":"pages/Earnings/代码随想录/链表.md"}'),o={name:"pages/Earnings/代码随想录/链表.md"},e=l(`<h2 id="链表特点" tabindex="-1">链表特点 <a class="header-anchor" href="#链表特点" aria-label="Permalink to &quot;链表特点&quot;">​</a></h2><ul><li>链表查找的时间复杂度 O(n),删除链表的复杂度O(1)</li><li>链表：通过指针串联在一起的线性解构，每一个节点由两部分组成，一个是数据域一个是指针域，最后一个节点的指针域指向null</li><li>链表是通过指针域的指针链接在内存中各个节点。</li><li>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 单链表</span></span>
<span class="line"><span style="color:#E1E4E8;"> struct ListNode {</span></span>
<span class="line"><span style="color:#E1E4E8;">     int val;  </span><span style="color:#6A737D;">// 节点上存储的元素</span></span>
<span class="line"><span style="color:#E1E4E8;">     ListNode </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">next;  </span><span style="color:#6A737D;">// 指向下一个节点的指针</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#B392F0;">ListNode</span><span style="color:#E1E4E8;">(int x) : </span><span style="color:#B392F0;">val</span><span style="color:#E1E4E8;">(x), </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">NULL</span><span style="color:#E1E4E8;">) {}  </span><span style="color:#6A737D;">// 节点的构造函数</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 单链表</span></span>
<span class="line"><span style="color:#24292E;"> struct ListNode {</span></span>
<span class="line"><span style="color:#24292E;">     int val;  </span><span style="color:#6A737D;">// 节点上存储的元素</span></span>
<span class="line"><span style="color:#24292E;">     ListNode </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">next;  </span><span style="color:#6A737D;">// 指向下一个节点的指针</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6F42C1;">ListNode</span><span style="color:#24292E;">(int x) : </span><span style="color:#6F42C1;">val</span><span style="color:#24292E;">(x), </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">NULL</span><span style="color:#24292E;">) {}  </span><span style="color:#6A737D;">// 节点的构造函数</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span></code></pre></div><p><strong>原型链</strong></p><ol><li>当我们访问一个对象属性，如果它不存在就从他的原型链上去寻找</li><li>本质就是链表，原型链上的节点就是各种原型对象</li><li>通过__proto__属性取连接各种原型对象 <code>instanceof 也是用到链表的思想</code></li></ol><h2 id="删除链表中的元素" tabindex="-1">删除链表中的元素 <a class="header-anchor" href="#删除链表中的元素" aria-label="Permalink to &quot;删除链表中的元素&quot;">​</a></h2><ol><li>设置虚拟头结点</li></ol><h2 id="两两交换" tabindex="-1"><em>两两交换 ！</em> <a class="header-anchor" href="#两两交换" aria-label="Permalink to &quot;*两两交换 ！*&quot;">​</a></h2><ul><li>虚拟头结点</li></ul><ol><li>先画图模拟下这个行为 之后再描述出来</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//[dummy ,1 ,2 ,3 ,4]</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//步骤1 虚拟头结点指向2</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//步骤2 2指向1</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//步骤3 1指向3</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//[dummy ,1 ,2 ,3 ,4]</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//步骤1 虚拟头结点指向2</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//步骤2 2指向1</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//步骤3 1指向3</span></span></code></pre></div><ol start="2"><li>注意 最后向前移动的时候需要一次移动两个节点</li></ol><h2 id="反转链表" tabindex="-1">反转链表 <a class="header-anchor" href="#反转链表" aria-label="Permalink to &quot;反转链表&quot;">​</a></h2><ol><li>p cur 转换指向</li><li>两个区间不断向后移动</li><li>返回p.next就是反向后的链表</li></ol><h2 id="删除链表" tabindex="-1">删除链表 <a class="header-anchor" href="#删除链表" aria-label="Permalink to &quot;删除链表&quot;">​</a></h2><ol><li>快的先走n步</li><li>快的慢的一起走，快的走到头，慢的这时候就处在倒数第n个</li><li>删除倒数n 就是把他的next指向nextnext</li></ol><h2 id="链表相交" tabindex="-1">链表相交 <a class="header-anchor" href="#链表相交" aria-label="Permalink to &quot;链表相交&quot;">​</a></h2><ol><li>长的先把自己多的走了</li><li>长的短的一起走，走到有一样的证明有香蕉，没有就没有</li></ol><h2 id="环形链表入口" tabindex="-1">环形链表入口 <a class="header-anchor" href="#环形链表入口" aria-label="Permalink to &quot;环形链表入口&quot;">​</a></h2><ol><li>快的走两步，慢的走一步，先看有没有环</li><li>有环的话就找到了相遇点</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;">(fast</span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">fast.next</span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">fast</span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;">slow){</span></span>
<span class="line"><span style="color:#E1E4E8;">        fast</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">fast.next.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">        slow</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">slow.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">fast</span><span style="color:#F97583;">||!</span><span style="color:#E1E4E8;">fast.next) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">//如果没找到就是没有环</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;">(fast</span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">fast.next</span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">fast</span><span style="color:#D73A49;">!=</span><span style="color:#24292E;">slow){</span></span>
<span class="line"><span style="color:#24292E;">        fast</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">fast.next.next;</span></span>
<span class="line"><span style="color:#24292E;">        slow</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">slow.next;</span></span>
<span class="line"><span style="color:#24292E;">    } </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">fast</span><span style="color:#D73A49;">||!</span><span style="color:#24292E;">fast.next) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">//如果没找到就是没有环</span></span></code></pre></div><ol start="3"><li>这个时候从头节点开始走一个，从相遇处也开始走一个，每次都走一步，他们相遇的点就是环的入口 <img src="`+p+`" alt="alt"></li></ol><blockquote><p>快的：x+n(z+y) 慢的:（x+y） 因为快的是一次走两步，所以 x+y+n(y+z)=2(x+y) =&gt; n(y+z)=x+y; x=n(y+z)-y =&gt; x=(n-1)(y+z)+z 当n=1 表示多跑一圈就追上了 x = z</p></blockquote><pre><code> z =&gt; 头节点开始一个，相遇节点开始一个，一起走，走到他们相遇就走了 z 
</code></pre><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//slow回到起点 fast还停留在相遇点 </span></span>
<span class="line"><span style="color:#6A737D;">//一起移动 他们相遇的点就是环的入口</span></span>
<span class="line"><span style="color:#E1E4E8;">    slow</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">head;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;">(fast</span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">fast.next</span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;">slow</span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;">fast){</span></span>
<span class="line"><span style="color:#E1E4E8;">        slow</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">slow.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">        fast</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">fast.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> slow;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//slow回到起点 fast还停留在相遇点 </span></span>
<span class="line"><span style="color:#6A737D;">//一起移动 他们相遇的点就是环的入口</span></span>
<span class="line"><span style="color:#24292E;">    slow</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">head;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;">(fast</span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">fast.next</span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;">slow</span><span style="color:#D73A49;">!=</span><span style="color:#24292E;">fast){</span></span>
<span class="line"><span style="color:#24292E;">        slow</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">slow.next;</span></span>
<span class="line"><span style="color:#24292E;">        fast</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">fast.next;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> slow;</span></span></code></pre></div>`,25),t=[e];function c(r,i,E,y,d,h){return a(),n("div",null,t)}const f=s(o,[["render",c]]);export{x as __pageData,f as default};
