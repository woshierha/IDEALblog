import{_ as e,o as n,c as t,Q as i}from"./chunks/framework.36c93c4c.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Earnings/手写/排序/index.md","filePath":"pages/Earnings/手写/排序/index.md"}'),o={name:"pages/Earnings/手写/排序/index.md"},l=i('<h3 id="常用的排序算法包括" tabindex="-1">常用的排序算法包括： <a class="header-anchor" href="#常用的排序算法包括" aria-label="Permalink to &quot;常用的排序算法包括：&quot;">​</a></h3><ol><li>冒泡排序（Bubble Sort）：基本思想是比较相邻两个元素的大小，如果前者比后者大则交换位置，一轮循环后，最大（或最小）的元素就“浮”到了最后面。时间复杂度为 O(n^2)。</li><li>选择排序（Selection Sort）：基本思想是每次从未排序的元素中选取一个最小的元素，放到已排序元素的末尾，直到全部排序完成。时间复杂度为 O(n^2)。</li><li>插入排序（Insertion Sort）：基本思想是将待排序数组分成已排序区间和未排序区间，每次从未排序区间中取出第一个元素，将其插入到已排序区间中的适当位置。时间复杂度为 O(n^2)。</li><li>希尔排序（Shell Sort）：是一种改进的插入排序，将待排序数组按照一定间隔分组，分别进行插入排序，缩小间隔，直到间隔为1时完成排序。时间复杂度介于 O(n) 和 O(n^2) 之间。</li><li>归并排序（Merge Sort）：基本思想是将待排序数组分成两部分，对每部分递归地进行归并排序，然后将两部分合并成一个有序序列。时间复杂度为 O(nlogn)。</li><li>快速排序（Quick Sort）：基本思想是选取一个元素作为基准值（pivot），将待排序数组分成小于基准值的部分和大于等于基准值的部分，然后递归地对这两部分进行快速排序，直到排序完成。时间复杂度为 O(nlogn)。</li><li>堆排序（Heap Sort）：基本思想是将待排序数组看作一个完全二叉树，每个节点的值都大于等于（或小于等于）其左右子节点的值，将其调整为大根堆（或小根堆），然后将根节点与末尾节点交换位置，对剩下的元素重新调整为堆，直到全部排序完成。时间复杂度为 O(nlogn)。</li></ol><ul><li>其中，插入排序和冒泡排序的时间复杂度较高，不适合大规模数据排序；选择排序和希尔排序相对来说较快，但是也不如归并排序、快速排序和堆排序效率高。归并排序和快速排序都是基于分治思想，效率较高，但是在最坏情况下的时间复杂度较高。堆排序在最坏情况下时间复杂度为 O(nlogn)，但是常数项比快排小，适合处理大规模数据。</li></ul>',3),a=[l];function r(s,_,c,d,p,S){return n(),t("div",null,a)}const u=e(o,[["render",r]]);export{h as __pageData,u as default};
