import{_ as l,o as a,c as i,Q as e}from"./chunks/framework.39f71bcb.js";const m=JSON.parse('{"title":"候选人前端开发能力考察","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Earnings/简历/问题整理.md","filePath":"pages/Earnings/简历/问题整理.md"}'),s={name:"pages/Earnings/简历/问题整理.md"},o=e(`<p>好的,我会将之前7部分内容按照以下类别进行整理汇总:</p><h2 id="html相关" tabindex="-1">HTML相关 <a class="header-anchor" href="#html相关" aria-label="Permalink to &quot;HTML相关&quot;">​</a></h2><ul><li>html语义化标签和作用</li></ul><ul><li>比如 footer article summary head section video figure</li><li>能够让内容更加直观，结构更加清晰，方便阅读和维护，有助于SEO，能够适应不同的设备</li></ul><ul><li>SEO方案,白帽和黑帽?</li></ul><ul><li>黑帽是指通过一些违规手段实现提高SEO，比如强行插入一些关键词、或者将一些无关的内容隐藏给用户，或者插入一些链接，复制和抄袭内容。</li><li>白帽指的是做好内容上的优化，通过数据监控来随时调整策略。</li></ul><h2 id="css相关" tabindex="-1">CSS相关 <a class="header-anchor" href="#css相关" aria-label="Permalink to &quot;CSS相关&quot;">​</a></h2><ul><li>CSS变量(不会)</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">---</span><span style="color:#B392F0;">mainColor</span><span style="color:#E1E4E8;">: blue</span></span>
<span class="line"><span style="color:#E1E4E8;"> .light {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">backroundColor</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;">(--mainColor)</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">---</span><span style="color:#6F42C1;">mainColor</span><span style="color:#24292E;">: blue</span></span>
<span class="line"><span style="color:#24292E;"> .light {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">backroundColor</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">var</span><span style="color:#24292E;">(--mainColor)</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span></code></pre></div><ul><li>实现换肤功能的思路?</li></ul><ul><li>可以通过CSS变量的方式来实现，首先定义主题色，然后通过style绑定主题，返回不同的主题色，点击按钮能够调整不同的主题色，改变主题色的属性就能够实现换肤。</li></ul><ul><li>伪类和伪元素的区别</li></ul><ul><li>伪类用于选择某些状态的元素，伪元素用于创建不存在的元素</li><li>伪元素常见只有<code>::after ::before</code></li><li>伪类 <code>:hover</code></li></ul><ul><li>如何理解原子化CSS,优劣?</li></ul><ul><li>优点： 可读性强，更加灵活，实现松耦合，更加易于重用，减小体积。</li><li>缺点： 增加学习成本，维护成本会增加。</li></ul><ul><li>flex布局,布局场景题</li><li>盒模型 <ul><li>怪异的话width是包含padding这些</li><li>标砖的话width是只有内容部分的</li></ul></li><li>css动画</li><li>css定位</li></ul><ul><li>position：absolute relative sticky fixed</li><li>相当于父级元素 ｜ 相对于自身 ｜ 在超出一定范围之后定位 ｜ 相对于视窗定位</li></ul><ul><li><p>CSS权重：</p><ul><li>ID选择器 【类选择器 属性选择器 伪类选择器】 【元素 伪元素选择器 】通用选择器 ！important</li><li>属性选择器 CSS 属性选择器匹配那些具有特定属性或属性值的元素。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">/* 存在 title 属性的 &lt;a&gt; 元素 */</span></span>
<span class="line"><span style="color:#E1E4E8;">    a[title] {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">color</span><span style="color:#E1E4E8;">: purple;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">/* 存在 title 属性的 &lt;a&gt; 元素 */</span></span>
<span class="line"><span style="color:#24292E;">    a[title] {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">color</span><span style="color:#24292E;">: purple;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span></code></pre></div></li></ul></li><li><p>z-index什么情况下生效 元素必须具有 position 属性。 元素必须具有相对或绝对定位。 元素必须具有比其父元素更高的 z-index 值。</p></li><li><p>层级比较关系原则</p><ul><li>如果是没有平行的情况下有z-index越大的 在上层</li><li>如果是父级则是始终在上层</li></ul></li><li><p>手打实现水平垂直居中(我写了三种方式,有时间的也可以写多点)</p><ol><li>flex布局</li><li>通过 margin实现</li><li>通过transform实现</li></ol></li><li><p>flex场景题</p></li><li><p>position的定位方式有哪几种?</p></li></ul><h2 id="js基础" tabindex="-1">JS基础 <a class="header-anchor" href="#js基础" aria-label="Permalink to &quot;JS基础&quot;">​</a></h2><ul><li>js数据类型</li></ul><ul><li>简单数据类型：Number Boolean String Null Undefiend Symbol BigInt</li><li>复杂数据类型：Object</li></ul><ul><li>怎么判断数据类型,基于原型链判断的方式</li></ul><ul><li>typeof</li><li>instanceOf</li><li>Object.prototype.toString.call()</li><li>.construcor</li></ul><ul><li><p>深拷贝和浅拷贝,手写深拷贝</p><ul><li>浅拷贝，拷贝的是引用，最终指向一个内存空间，因此会影响原来的值 Object.assign() 或 展开运算符(...)实现。</li><li>深拷贝，拷贝的是一个新的内存地址，要考虑循环引用的情况 JSON.parse(JSON.stringify(obj))</li></ul></li><li><p>js声明变量的方式,区别</p></li><li><p>虚拟dom</p></li><li><p>如何将对象转为JSON?如何让这个JSON格式化?</p></li><li><p>Array(100).map(i=&gt;1)的输出</p></li><li><p>反转字符串和打乱字符串</p></li><li><p>let var 作用域区别</p></li><li><p>引用数据类型与基本数据类型区别</p></li></ul><ul><li>引用数据类型存储在栈，存储值，指针</li><li>引用数据类型存储在堆中，存储引用，具体值</li></ul><ul><li>event.target 和 event.currentTarget</li></ul><ul><li>事件冒泡：event.currentTarget（当前元素），event.target（目前元素）</li></ul><ul><li>代码题:实现深拷贝,考虑边界问题</li><li>es6新特性</li><li>给了setTimeout,promise,同步代码同时存在的那种题</li><li>手撕二分,深拷贝</li><li>闭包和引用的笔试题</li><li>在浏览器输入url解析成页面要哪几步</li><li>用setTimeOut实现setInterval(手撕)解释笔试题你为啥是那个答案</li></ul><h2 id="js进阶" tabindex="-1">JS进阶 <a class="header-anchor" href="#js进阶" aria-label="Permalink to &quot;JS进阶&quot;">​</a></h2><ul><li>防抖和节流,防抖 <ul><li>防抖解决：防止多次的重复行为，防抖只触发一次</li><li>节流：让高频行为按一定的频率执行防止笑消耗过大，节流会按照一定的频率来触发。</li></ul></li><li>vue的事件队列机制(异步渲染) <ol><li>数据监听Observer:通过Object.defineProperty()来监听数据的变化。</li><li>订阅者Watcher:Watcher订阅了Obeserver的数据变化,一旦有变化,会将Watcher加入队列Queue。</li><li>更新队列Queue:异步执行所有Watcher,进行DOM更新。</li><li>nextTick:下一个事件循环中的回调函数。</li></ol></li><li>任务循环机制</li><li>instanceof 原理与作用</li><li>手撕 Promise</li><li>如何判断用户更喜欢哪个模块</li><li>瀑布流式图片,监听click</li></ul><h2 id="算法题" tabindex="-1">算法题 <a class="header-anchor" href="#算法题" aria-label="Permalink to &quot;算法题&quot;">​</a></h2><ul><li>手写千分位转换(三位一加逗号)</li><li>手写深拷贝</li><li>将输入字符串去重按字典序输出</li><li>二分查找</li></ul><h2 id="网络相关" tabindex="-1">网络相关 <a class="header-anchor" href="#网络相关" aria-label="Permalink to &quot;网络相关&quot;">​</a></h2><ul><li><p>http2和1.1的区别</p></li><li><p>各种状态跨域方案</p></li><li><p>localhost 和127.0.0.1的区别 <code>localhost</code> 和 <code>127.0.0.1</code> 都是用于本地主机（即本机）访问的地址，它们在大多数情况下是等价的，但有一些微小的区别。</p><ol><li><p><strong>localhost</strong>： <code>localhost</code> 是一个主机名（hostname），指向本地计算机的回送地址。在网络通信中，主机名用于标识计算机。当你在浏览器中输入 <code>localhost</code> 时，实际上是在访问你所在计算机的本地服务。它通常映射到 IPv4 地址 <code>127.0.0.1</code> 和 IPv6 地址 <code>::1</code>。在绝大多数情况下，<code>localhost</code> 和 <code>127.0.0.1</code> 都会指向同一个本地回送地址。</p></li><li><p><strong>127.0.0.1</strong>： <code>127.0.0.1</code> 是一个特殊的 IPv4 地址，被称为回送地址（Loopback Address）。它用于在本地主机上进行网络通信，可以用于访问本地计算机上的网络服务，而不需要通过网络接口。当你在浏览器中输入 <code>http://127.0.0.1</code> 时，实际上是访问了本地计算机上的 Web 服务。</p></li></ol><p>总结区别：</p><ul><li><code>localhost</code> 是一个主机名，可以映射到 IPv4 地址 <code>127.0.0.1</code> 或 IPv6 地址 <code>::1</code>。</li><li><code>127.0.0.1</code> 是一个特殊的 IPv4 回送地址，用于本地主机上的网络通信。</li></ul><p>在大部分情况下，你可以将 <code>localhost</code> 和 <code>127.0.0.1</code> 视为等价的，都用于在本地主机上访问本地服务。在开发过程中，你可能会经常使用它们来测试和调试本地的应用程序。</p></li><li><p>网络状态码</p></li><li><p>tcp三次握手,四次挥手</p></li><li><p>解决跨域</p></li><li><p>跨域问题怎么解决?后端是怎样配置CORS?</p></li><li><p>http2</p></li><li><p>tcp三次握手,四次挥手</p></li></ul><h2 id="vue相关" tabindex="-1">Vue相关 <a class="header-anchor" href="#vue相关" aria-label="Permalink to &quot;Vue相关&quot;">​</a></h2><ul><li>vue常用生命周期</li><li>项目原来用的vue2后来改用vue3为什么?它们的区别?</li><li>vue原理</li><li>vuex</li></ul><h2 id="react相关" tabindex="-1">React相关 <a class="header-anchor" href="#react相关" aria-label="Permalink to &quot;React相关&quot;">​</a></h2><ul><li>react router有几种实现方式?</li></ul><h2 id="小程序相关" tabindex="-1">小程序相关 <a class="header-anchor" href="#小程序相关" aria-label="Permalink to &quot;小程序相关&quot;">​</a></h2><ul><li>小程序生命周期</li><li>小程序带参路由跳转</li></ul><h2 id="git相关" tabindex="-1">Git相关 <a class="header-anchor" href="#git相关" aria-label="Permalink to &quot;Git相关&quot;">​</a></h2><ul><li>git常用命令</li></ul><h2 id="webpack相关" tabindex="-1">Webpack相关 <a class="header-anchor" href="#webpack相关" aria-label="Permalink to &quot;Webpack相关&quot;">​</a></h2><ul><li>你所了解的webpack是什么?</li><li>用webpack打包,减少包的体积,应该怎么做?</li></ul><h2 id="项目相关" tabindex="-1">项目相关 <a class="header-anchor" href="#项目相关" aria-label="Permalink to &quot;项目相关&quot;">​</a></h2><ul><li>实习项目</li></ul><h2 id="移动端" tabindex="-1">移动端 <a class="header-anchor" href="#移动端" aria-label="Permalink to &quot;移动端&quot;">​</a></h2><ul><li>移动端相关</li></ul><h2 id="开源相关" tabindex="-1">开源相关 <a class="header-anchor" href="#开源相关" aria-label="Permalink to &quot;开源相关&quot;">​</a></h2><ul><li>了解的开源协议有哪些(不会)</li><li>了解的构建工具,区别?</li></ul><h2 id="npm相关" tabindex="-1">npm相关 <a class="header-anchor" href="#npm相关" aria-label="Permalink to &quot;npm相关&quot;">​</a></h2><ul><li><p>npm包的发布流程</p><ul><li>npm init新建项目</li><li></li></ul></li><li><p>package.json的作用<br> 项目依赖管理：package.json 记录了项目所依赖的各种包（库）及其版本信息。在 Node.js 中，使用 npm 或者 yarn 等包管理工具时，会根据 package.json 中的依赖信息自动安装所需的包。这使得在不同环境中（如开发环境、生产环境）或者在其他机器上重新部署项目时，可以确保依赖的一致性。</p><p>项目信息记录：package.json 中还包含了项目的一些基本信息，例如项目名称、版本、作者、描述等。这些信息对于其他开发者或团队成员了解项目很有帮助。</p><p>脚本定义：在 package.json 中，可以定义一系列脚本命令。这些脚本可以用于快速执行常用的开发任务，比如启动开发服务器、运行测试、打包项目等。在使用 npm 或 yarn 运行脚本时，只需要简单的一个命令就可以执行。</p><p>版本管理：通过 package.json 中的版本号，可以确保项目的稳定性和可追溯性。项目的版本号通常遵循语义化版本规范（SemVer），其中包含主版本号、次版本号和修订号，使得开发者可以明确知道项目的变更情况。</p><p>发布与分享：当你希望将自己的项目分享给其他人使用时，package.json 是必不可少的。通过 package.json，其他人可以了解你的项目依赖和运行脚本，从而更容易在他们的开发环境中进行部署和运行。</p></li><li><p>package.json的版本号规则</p></li><li><p>node版本发布迭代的过程</p></li></ul><h2 id="服务器相关" tabindex="-1">服务器相关 <a class="header-anchor" href="#服务器相关" aria-label="Permalink to &quot;服务器相关&quot;">​</a></h2><ul><li>SSR和SSG?</li></ul><h2 id="其他语言相关" tabindex="-1">其他语言相关 <a class="header-anchor" href="#其他语言相关" aria-label="Permalink to &quot;其他语言相关&quot;">​</a></h2><ul><li>除了JS还会什么语言,熟悉程度如何?</li></ul><h2 id="性能相关" tabindex="-1">性能相关 <a class="header-anchor" href="#性能相关" aria-label="Permalink to &quot;性能相关&quot;">​</a></h2><ul><li>移动端的性能指标?</li></ul><h2 id="多端相关" tabindex="-1">多端相关 <a class="header-anchor" href="#多端相关" aria-label="Permalink to &quot;多端相关&quot;">​</a></h2><ul><li>跨端方案对比</li></ul><h2 id="设计模式相关" tabindex="-1">设计模式相关 <a class="header-anchor" href="#设计模式相关" aria-label="Permalink to &quot;设计模式相关&quot;">​</a></h2><ul><li>了解的设计模式</li><li>工厂模式和抽象工厂的区别(不会)<br> 工厂模式使用普通函数返回对象实例，而构造函数使用 new 关键字来创建对象实例。 工厂模式隐藏了对象创建的过程，构造函数在函数内部使用 this 来初始化对象。 工厂模式创建的对象没有原型链继承，每个对象都是独立的，而构造函数创建的对象可以共享原型对象上的方法和属性。 工厂模式更加灵活，可以根据传入的参数返回不同的对象，而构造函数在创建对象时需要使用特定的构造函数名。 构造函数创建的对象通常使用首字母大写的函数名作为构造函数的标识，而工厂模式没有这个限制。</li></ul><h2 id="源码相关" tabindex="-1">源码相关 <a class="header-anchor" href="#源码相关" aria-label="Permalink to &quot;源码相关&quot;">​</a></h2><ul><li>看过那些源码,看源码的意义</li></ul><h2 id="其它" tabindex="-1">其它 <a class="header-anchor" href="#其它" aria-label="Permalink to &quot;其它&quot;">​</a></h2><ul><li>eslint插件原理</li><li>进程和线程的区别(忘了)</li><li>进程调度(忘了)</li><li>了解的锁(不会)</li><li>平时学前端的方式,未来规划之类的</li><li>封装组件</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">         &lt;</span><span style="color:#79B8FF;">Atable</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">ref</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&#39;atable&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">module</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&#39;journal&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">//module为配置文件引入的名称 配置文件位置：@/config/table/apps 配置入口文件：@/config/table/index.ts</span></span>
<span class="line"><span style="color:#E1E4E8;">        /&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">         &lt;</span><span style="color:#005CC5;">Atable</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">ref</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&#39;atable&#39;</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">module</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&#39;journal&#39;</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">//module为配置文件引入的名称 配置文件位置：@/config/table/apps 配置入口文件：@/config/table/index.ts</span></span>
<span class="line"><span style="color:#24292E;">        /&gt;</span></span></code></pre></div><ol><li>首先定义组件的基本结构，组件名称，组件的内容涉及的字段，各类方法，以及如何处理数据，定义基本的方法，定义配置文件格式。</li><li>查找对应的组件文件，通过modules的方式导入配置文件，将modules名称作为参数传入这个自定义组件中，会根据获取到的所有内容去匹配对应的配置文件。遍历其中的每一项找到对应匹配的元素并添加。</li><li>在main.js中注册全局组件。</li></ol><p>如此分类汇总是否合理?还有需要调整的地方吗?我会继续根据您的反馈进行完善。</p><p>组件库设计要考虑的原则和封装方式主要有:</p><p>可复用性:组件要有较高的可复用性,addButton / addIcon 等都可以作为可复用组件。 单一职责:每个组件只做一件事,保持组件的纯粹性。 独立性:组件之间松耦合,提高独立可用性。 可组合性:像Lego积木一样可以组合使用各组件。 API设计:组件需要提供清晰、易用的API。 样式定制:支持样式定制以适应不同场景。 规范性:命名、代码风格等要有一定规范性。 封装一个组件需要考虑:</p><p>接口:组件对外暴露的 API、属性、事件等接口。 功能:需要实现的功能点。 状态:组件中的状态管理。 样式:组件的视觉样式可定制性。 扩展性:如插槽、事件等扩展机制。 规范性:代码结构清晰,命名规范等。 文档:组件使用文档的编写。</p><p>根据提供的简历,我对该候选人的前端开发能力进行了分析,并提出了以下几个可以用来检验其技能的问题:</p><h1 id="候选人前端开发能力考察" tabindex="-1">候选人前端开发能力考察 <a class="header-anchor" href="#候选人前端开发能力考察" aria-label="Permalink to &quot;候选人前端开发能力考察&quot;">​</a></h1><ul><li>webpack构建流程</li></ul><ul><li>初始化参数：从配置文件和命令行语句中读取参数，合并成最终的参数。加载 Plugin ，实例化 Compiler 。</li><li>用上一 步得到的参数初始化 Comp il er 对象，加载所有配置的插件，通 过执行对象的 run 方法开始执行编译 。通过配置项找到对应的entry入口，对其中的模块调用对应的loader进行转换，同时对该文件依赖的其他模块也完成转换</li><li>对转换之后的文件按照依赖关系，将多个模块大包生成chunk，将每个chunk转换成单独的文件，加入到输出列表后，确定好输出内容之后，根据指定的输出目录将最终能够直接运行的bundle.js输出到指定的文件夹中。</li></ul><h2 id="项目经历相关" tabindex="-1">项目经历相关 <a class="header-anchor" href="#项目经历相关" aria-label="Permalink to &quot;项目经历相关&quot;">​</a></h2><ul><li>小桔租买车项目中使用了Vue和Weex开发,请你聊聊Weex的特点和跨端实现原理。Weex和React Native的区别是什么? Weex 和 React Native 都是用于开发跨平台移动应用的框架，但它们有一些不同之处。下面是它们之间的一些区别：</li></ul><ol><li><p><strong>语言和框架：</strong></p><ul><li>Weex：Weex 使用 Vue.js 作为主要的开发语言和框架。开发者使用 Vue.js 的语法来构建应用界面和逻辑。</li><li>React Native：React Native 使用 React.js 作为主要的开发语言和框架。开发者使用 JSX 语法来构建应用界面和逻辑。</li></ul></li><li><p><strong>界面渲染：</strong></p><ul><li>Weex：Weex 采用原生组件的渲染方式，将 Vue.js 模板转换为原生控件，然后在不同平台上进行渲染。</li><li>React Native：React Native 通过桥接机制，将 React 组件映射到平台的原生视图，然后由原生系统来渲染。</li></ul></li><li><p><strong>组件库：</strong></p><ul><li>Weex：Weex 提供了一套独立的组件库，与 Vue.js 配合使用。这些组件在不同平台上会映射为对应的原生控件。</li><li>React Native：React Native 提供了一套基础组件库，与 React.js 配合使用。开发者也可以使用第三方组件库来增加功能。</li></ul></li><li><p><strong>开发体验：</strong></p><ul><li>Weex：Weex 开发者可以直接使用 Vue.js 的开发工具和调试工具，借助 Vue DevTools 进行开发。</li><li>React Native：React Native 提供了 React Developer Tools 和一些调试工具，但与 Vue.js 的开发体验略有不同。</li></ul></li><li><p><strong>生态系统和社区：</strong></p><ul><li>Weex：Weex 相对于 React Native 的社区规模较小，但也有一些活跃的开发者和项目。</li><li>React Native：React Native 拥有庞大的社区和生态系统，有许多第三方库、工具和插件可用。</li></ul></li><li><p><strong>跨平台支持：</strong></p><ul><li>Weex：Weex 支持 iOS、Android 和 Web 平台，但 Web 平台的支持相对较弱。</li><li>React Native：React Native 也支持 iOS、Android 和 Web 平台，但 Web 平台的支持是通过第三方库实现的。</li></ul></li></ol><p>需要注意的是，两者的核心思想都是通过 JavaScript 来描述应用界面和逻辑，然后将其转化为原生组件或视图。选择使用哪个框架取决于你对 Vue.js 或 React.js 的熟悉程度、项目的需求以及你对特定平台的支持需求。</p><ul><li>金店小程序CI/CD项目中使用了微前端框架qiankun,请你说明qiankun的工作方式、应用场景和实现多个子应用通信的方式。 <h4 id="样式隔离" tabindex="-1">样式隔离： <a class="header-anchor" href="#样式隔离" aria-label="Permalink to &quot;样式隔离：&quot;">​</a></h4><ul><li>使用了shadowDom 在加载子应用时加载样式，重新加载时卸载样式。</li></ul><h4 id="js沙箱隔离" tabindex="-1">js沙箱隔离 <a class="header-anchor" href="#js沙箱隔离" aria-label="Permalink to &quot;js沙箱隔离&quot;">​</a></h4><ul><li>快照沙箱（污染全局变量并且需要遍历window） 保存进入之前的window信息快照，退出时将当前的window和快照中的window做对比，恢复为之前的快照window。</li><li>代理沙箱 （单例沙箱 多例沙箱） 单例（污染全局） 默认 ：通过 map记录了更新和新增的内容，记录当前修改的属性，改变window的变量，退出时将修改之前的值赋给window 多例（不会污染全局）：激活沙箱之后，首先拷贝window的一些原生属性，放在fakewindow中，如果是原生属性，修改全局window，反之修改fakewindow，对沙箱复制只会影响fakewindow而不会影响raw window（相当于window中存放公用属性，fake window中存放的是私有的属性）</li></ul></li><li>媒体融合数据服务平台项目用到了Echarts和D3开发数据可视化,请你谈谈Echarts和D3的不同之处,以及开发可交互动态图表的注意事项。</li></ul><h2 id="实习经历相关" tabindex="-1">实习经历相关 <a class="header-anchor" href="#实习经历相关" aria-label="Permalink to &quot;实习经历相关&quot;">​</a></h2><ul><li>滴滴出行项目中提到实践了组件化开发,请你谈谈组件封装的重要原则。在项目中如何实现组件的复用? 单一职责原则:每个组件只负责一个功能,不要在一个组件中混杂多个不同的功能。 高内聚低耦合:组件内部功能需要高度内聚,组件之间需要低耦合。 开闭原则:组件对扩展开放,对修改关闭。通过props、事件等扩展组件功能。 可复用性:组件需要具有一定复用性,不能过于具体。 可组合性:组件像积木一样可以组合使用。 状态管理:正确管理组件的状态,比如提升状态、redux等。 API设计:组件需要暴露简洁易懂的API给使用者。 样式隔离:组件样式和其他组件隔离,避免冲突。 深层嵌套:避免组件结构过深嵌套,保持较平的结构。 注释文档:组件需要可读的注释、文档说明使用方法。</li><li>京东科技项目使用CSS Module解决样式问题,请你说说CSS Module的工作原理是什么?相比普通CSS有什么优势?</li></ul><ul><li>CSS module会收集各组件对类名的引用，并且替换为全局唯一类名</li><li>安全使用通用名称类名，体现组件化的开发思想。</li><li>例子： <code>import cssmodule </code>样式 <code>import styles from &#39;./.css&#39;</code> 使用 <code>&lt;div class = {style.title}&gt; &lt;/div&gt;</code></li><li>会为这些样式生成一个唯一的标识符</li></ul><ul><li>实习中提到完成了前端性能优化,请你谈谈前端性能优化通常从哪几个方面入手?页面优化需要注意什么?</li></ul><h2 id="概括性问题" tabindex="-1">概括性问题 <a class="header-anchor" href="#概括性问题" aria-label="Permalink to &quot;概括性问题&quot;">​</a></h2><ul><li><p>你最擅长的前端技术栈是什么?使用该技术栈开发过什么项目,从中获取了哪些经验?</p></li><li><p>你认为一个合格的前端工程师必须掌握哪些技能和知识?你目前还有哪些不足需要改进?</p></li><li><p>未来你计划在前端技术方面有哪些突破和进步?怎样持续学习来提高自己?</p></li></ul><p>以上这些问题设计都聚焦在项目经验和技术细节上,可以全面考察该候选人的前端开发能力。提问过程中需要注意观察其响应的流畅度、技术深度等。</p>`,88),n=[o];function t(p,r,c,u,d,h){return a(),i("div",null,n)}const g=l(s,[["render",t]]);export{m as __pageData,g as default};
